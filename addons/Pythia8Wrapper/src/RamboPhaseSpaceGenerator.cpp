/*
 *  CepGen: a central exclusive processes event generator
 *  Copyright (C) 2024  Laurent Forthomme
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Pythia8/PhaseSpace.h>

#include <vector>

#include "CepGen/Core/Exception.h"
#include "CepGen/Modules/PhaseSpaceGeneratorFactory.h"
#include "CepGen/Physics/PDG.h"
#include "CepGen/Physics/PartonFlux.h"
#include "CepGen/Process/CentralPhaseSpaceGenerator.h"
#include "CepGen/Process/FactorisedProcess.h"
#include "CepGen/Utils/Math.h"

using namespace cepgen;

class RamboPhaseSpaceGenerator : public cepgen::PhaseSpaceGenerator {
public:
  explicit RamboPhaseSpaceGenerator(const ParametersList& params)
      : PhaseSpaceGenerator(params),
        random_engine_(new Pythia8RandomWrapper(coords_)),
        random_(steer<unsigned long long>("seed")),
        rambo_(&random_),
        partons_(steer<std::vector<int> >("partons")),
        central_(steer<std::vector<int> >("ids")) {
    random_.rndmEnginePtr(random_engine_);
    for (const auto& id : partons_)
      masses_.emplace_back(PDG::get().mass(id));
    for (const auto& id : central_)
      masses_.emplace_back(PDG::get().mass(id));
  }

  static ParametersDescription description() {
    auto desc = CentralPhaseSpaceGenerator::description();
    desc.setDescription("Rambo central phase space generator");
    desc.add<unsigned long long>("seed", 42);
    return desc;
  }

  pdgids_t partons() const override { return pdgids_t(partons_.begin(), partons_.end()); }

  pdgids_t central() const override { return pdgids_t(central_.begin(), central_.end()); }

  void initialise(proc::FactorisedProcess* process) override {
    proc_ = process;
    ecm_ = process->sqrtS();
    const auto ndim = masses_.size() * 4;
    coords_.resize(ndim);
    for (size_t i = 0; i < ndim; ++i)
      (*proc_).defineVariable(coords_[i], proc::Process::Mapping::linear, {0., 1.}, "x" + std::to_string(i));
  }

  double generate() override {
    dynamic_cast<Pythia8RandomWrapper*>(random_engine_.get())->reset();
    const auto weight = rambo_.genPoint(ecm_, masses_, vecs_);
    if (!utils::positive(weight))
      return 0.;
    if (vecs_.size() < masses_.size())
      throw CG_FATAL("RamboPhaseSpaceGenerator:generate") << "Not enough momenta were generated by Rambo.";
    const auto convert_momentum = [](const Pythia8::Vec4& vec) {
      return Momentum::fromPxPyPzE(vec.px(), vec.py(), vec.pz(), vec.e());
    };
    proc_->q1() = convert_momentum(vecs_.at(0));
    proc_->q2() = convert_momentum(vecs_.at(1));
    for (size_t i = 0; i < central_.size(); ++i)
      proc_->pc(i) = convert_momentum(vecs_.at(2 + i));
    return weight;
  }

private:
  class Pythia8RandomWrapper final : public Pythia8::RndmEngine {
  public:
    explicit Pythia8RandomWrapper(std::vector<double>& coords) : coords_(coords) {}
    void reset() { index_ = 0; }
    double flat() override { return coords_.at(index_++); }

  private:
    std::vector<double>& coords_;
    size_t index_{0};
  };

  std::vector<double> coords_;
  const Pythia8::RndmEnginePtr random_engine_;
  Pythia8::Rndm random_;
  Pythia8::Rambo rambo_;
  const std::vector<int> partons_, central_;

  proc::FactorisedProcess* proc_;  //NOT owning
  double ecm_{0.};
  std::vector<double> masses_;
  std::vector<Pythia8::Vec4> vecs_;
};
REGISTER_PSGEN("rambo", RamboPhaseSpaceGenerator);
